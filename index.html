  <!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 2</title>
    <script src="http://cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body style="background-color:black;">

<script type="text/javascript">

{
  var players=[];
  var rocks = [];
  var star = [];
  var missiles = [];
  var pings = [];
  var pongs = [];
  var gCoupe;
  var rCoupe;
  var shipList = [];
  var t;
  var dt;
  var date;
  var spriteview;
  var pingview; //light switch
  var pongview;
  var blipview;
  var activeShip;
  var nameInc;
  var mouseLine;
  var mouseText;
  var mapEdge = 1000; //max x and y and negative for mins
  var aMissile;
  var pointer;
  var td = false;
  var accX;
  var accY;
  var gameSpeed = 5;
} //GLOBAL initialize

var MenuScene = new Phaser.Class({
  Extends: Phaser.Scene,
  initialize:
  function MenuScene ()
  {
      Phaser.Scene.call(this, { key: 'MenuScene' });
  },
  preload: function ()
    {
      this.load.image('star', 'star.png');
    },
    create: function ()
    {
      this.scene.start("GameScene");
    }
  });

var GameScene = new Phaser.Class({
  Extends: Phaser.Scene,
  initialize:

  function GameScene ()
  {
      Phaser.Scene.call(this, { key: 'GameScene' });
  },


    preload: function ()
    {
      this.load.image('coupe', 'coupe.png');
      this.load.image('rocks', 'bomb.png');
      this.load.image('star', 'star.png');
      this.load.image('starbg', 'starbg.png');
      this.load.image('missile', 'missile.png');
      this.load.spritesheet('asplode', 'splode.png',{frameWidth: 32, frameHeight: 32, endFrame: 2 });

    },

    create: function ()
    {



      var config = {
        key: 'explode',
        frames: this.anims.generateFrameNumbers('asplode', { start: 0, end: 2, first: 0 }),
        frameRate: 12,
        hideOnComplete: true
      }
      this.anims.create(config);

      date = new Date;
      t = date.getTime()/1000;

      pi = 3.141592653;
      nameInc = 0;
{ //keys initialize
      keys = this.input.keyboard.createCursorKeys();
      IKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.I);
      KKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.K);
      LKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.L);
      OKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.O);
      PKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P);
      RKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
      TKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.T);
      QKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q);
      WKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);
      EKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);
      AKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
      SKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
      DKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);
      XKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.X);
      ZKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z);
      MKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.M);
      PLUSKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.PLUS);
      MINUSKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.MINUS);
}
      pointer = this.input.activePointer;
      accX=0;
      accY=0;

      cam = this.cameras.main;
      cam.setViewport(210,0,540,540);

      cam.followOffset.set(-100, -100);
      cam.setBounds(-mapEdge, -mapEdge, 2*mapEdge, 2*mapEdge);
      zoom = 1.0;

      camL = this.cameras.add();
      camL.setViewport(0, 0, 210, 540);
      camL.setScroll(-2*mapEdge,0);
      menuPanel = new Phaser.Geom.Rectangle(-2*mapEdge,0,200,120);
      pingPanel = new Phaser.Geom.Rectangle(-2*mapEdge,120,170,200);
      pingAMinus = new Phaser.Geom.Rectangle(-2*mapEdge+10,130,70,60);
      pingAPlus = new Phaser.Geom.Rectangle(-2*mapEdge+90,130,70,60);
      pingButton = new Phaser.Geom.Rectangle(-2*mapEdge+10,200,150,110);
      accelCircle1 = new Phaser.Geom.Circle(-2*mapEdge+105,435,105);
      accelCircle2 = new Phaser.Geom.Circle(-2*mapEdge+105,435,90);

      camR = this.cameras.add();
      camR.setViewport(750, 0, 210, 540);
      camR.setScroll(2*mapEdge,0);
      resPanel = new Phaser.Geom.Rectangle(2*mapEdge+20,0,200,120);
      targetPanel = new Phaser.Geom.Rectangle(2*mapEdge+40,120,170,200);
      zoomMinusButton = new Phaser.Geom.Rectangle(2*mapEdge+50,130,70,60);
      zoomPlusButton = new Phaser.Geom.Rectangle(2*mapEdge+130,130,70,60);
      targetButton = new Phaser.Geom.Rectangle(2*mapEdge+50,200,70,110);
      fireButton = new Phaser.Geom.Rectangle(2*mapEdge+130,200,70,110);
      pingCircle1 = new Phaser.Geom.Circle(2*mapEdge+105,435,105);
      pingCircle2 = new Phaser.Geom.Circle(2*mapEdge+105,435,90);

{ //gCoupe construction
      gCoupe = this.add.image(0,0, 'coupe')
      gCoupe.player=players[1];  //player controlled
      gCoupe.rv=0.0;
      gCoupe.vx=0.0;
      gCoupe.vy=0.0;
      gCoupe.amax=gameSpeed; // maximum available thrust
      gCoupe.rmax=0.05; // maximum rotation in rad/sec
      gCoupe.ramax=0.1; // maximum rotational velocity change per second
      gCoupe.setScale(0.2);
      gCoupe.tint = 0x20ff20;  //bright green
      gCoupe.mReady = true;
      gCoupe.mTimer = 0;
      gCoupe.pReady = true;
      gCoupe.pTimer = 0;
      gCoupe.target=null;
      gCoupe.blips=[];
      gCoupe.bliplines=[];
      gCoupe.contacts=[]
      gCoupe.pA=0;
      gCoupe.pW=pi; // +/- 0..pi
      gCoupe.mCount=5;
      cam.startFollow(gCoupe);
      gCoupe.name = 'gCoupe';
      shipList.push(gCoupe);

      players[0] = [];
      players[0].currentShip = gCoupe;
      players[0].isHuman = true;
      players[0].isLocal = true;
      players[0].camera = cam;


}
{ //rCoupe construction
      rCoupe = this.add.image(0,0, 'coupe')
      //rCoupe.visible = false
      rCoupe.x = (Math.random()-0.5)*200;
      rCoupe.y = (Math.random()-0.5)*200 ;
      rCoupe.player = players[0];  // NPC
      rCoupe.rv=0.0;
      rCoupe.vx=0.0;
      rCoupe.vy=0.0;
      rCoupe.amax=gameSpeed; // maximum available thrust
      rCoupe.rmax=0.05; // maximum rotation in rad/sec
      rCoupe.ramax=0.1; // maximum rotational velocity change per second
      rCoupe.setScale(0.2);
      rCoupe.tint = 0xff2020;  //bright red
      rCoupe.mReady = true;
      rCoupe.mTimer = 0;
      rCoupe.pReady = true;
      rCoupe.pTimer = 0;
      rCoupe.target = null;
      rCoupe.mCount = 5;
      rCoupe.blips = [];
      rCoupe.name = 'rCoupe';
      shipList.push(rCoupe);

} //rCoupe initialize
      mindist=4*mapEdge;

      graphics = this.add.graphics({ lineStyle: { width: 2, color: 0x4444ff, alpha: 1 } });

      fM = () => this.add.image(-mapEdge-10, -mapEdge-10, 'missile');

      for (i=0; i<100; i++){  //rocks construction
        rocks[i] = this.add.image(0,0, 'rocks')
        rocks[i].visible = false;
        rocks[i].setScale(0.2);
        rocks[i].rotation=Math.random()*2*pi;
        rocks[i].rv=(Math.random()-0.5)*0.2;
        rocks[i].x=Math.random()*mapEdge*2-mapEdge;
        rocks[i].y=Math.random()*mapEdge*2-mapEdge;
        rocks[i].vx=(rocks[i].y / mapEdge*2)*10 + (Math.random()-0.5)*0.2 ;
        rocks[i].vy= (Math.random()-0.5)*0.2 ;
      }

      starfield = this.add.image(0,0,'starbg');
      starfield.setScale(0.8);
      starfield.alpha = 0.3;
      starfield.setDepth(-1);
      starfield.setOrigin(0,0);
      starfield.setScrollFactor(0);

      tX = this.add.text(0,10,'X: ' + gCoupe.x);
      tX.fixedToCamera=true;
      tX.setScrollFactor(0,0);


    }, //create end


     update: function ()
    {
      date = new Date();
      dt = date.getTime()/1000-t; //  time in seconds elapsed since last frame
      t = date.getTime()/1000;    // timestamp in seconds of this frame


      if (gCoupe.mTimer < t)
        gCoupe.mReady = true;
      if (gCoupe.pTimer < t)
        gCoupe.pReady = true;
      if (rCoupe.mTimer < t)
        rCoupe.mReady = true;
      if (rCoupe.pTimer < t)
        rCoupe.pReady = true;

      if (PLUSKey.isDown) // to zoom in
        zoom*=1.02;
      if (MINUSKey.isDown) // to zoom out
        zoom/=1.02;
      if (zoom>3.0) zoom=3.0;
      if (zoom<0.5) zoom=0.5;
      cam.setZoom(zoom);

      if (WKey.isDown) accY=-1;
        else if (SKey.isDown) accY=1;
          else accY=0;

      if (AKey.isDown) accX=-1;
        else if (DKey.isDown) accX=1;
          else accX=0;

      if ((!!accX)||(!!accY)){
        gCoupe.rotation = Math.atan2(accY,(accX+0.001))+pi/2;
        accelerateObject(gCoupe);
      }
      accelCircle2.x=-2*mapEdge+105+15*accX;
      accelCircle2.y=435+15*accY;

      if (TKey.isDown) //magically rotate gCoupe toward rCoupe
        {
          td = true;
        } else {
          if (td) //TKey.release
          {
            nextTarget(gCoupe);
            td=false;
          }
        }

      if ((pointer.isDown)||(PKey.isDown)) //send ping from gCoupe
        {
          ping(gCoupe);
        }
      if (keys.space.isDown) //fire a missile
        if (gCoupe.mReady)
        {
          fireMissile(gCoupe,gCoupe.target);
        }

      if (QKey.isDown) //accelerate gCoupe toward rCoupe
        {
          gCoupe.pW-=0.02;
          if (gCoupe.pW>pi/2)
            gCoupe.pW-=0.02; //do it faster when filling
          if (gCoupe.pW<pi/12)
            gCoupe.pW=pi/12;
        }
      if (EKey.isDown) //accelerate gCoupe toward rCoupe
        {
          gCoupe.pW+=0.02;
          if (gCoupe.pW>pi/2)
            gCoupe.pW+=0.02; //do it faster when filling
          if (gCoupe.pW>pi)
            gCoupe.pW=pi;
        }

      if (keys.up.isDown) //accelerate gCoupe toward rCoupe
        {
          if (gCoupe.target===null)
            accelerateAtAngleTo(gCoupe,rCoupe,pi);
          else accelerateAtAngleTo(gCoupe,gCoupe.target,pi);
        }
      if (keys.left.isDown) //T key to magically rotate gCoupe toward rCoupe
        {
          if (gCoupe.target===null)
            accelerateAtAngleTo(gCoupe,rCoupe,pi/2);
          else accelerateAtAngleTo(gCoupe,gCoupe.target,pi/2);
        }
      if (keys.right.isDown) //accelerate gCoupe away from rCoupe
        {
          if (gCoupe.target===null)
            accelerateAtAngleTo(gCoupe,rCoupe,0);
          else accelerateAtAngleTo(gCoupe,gCoupe.target,0);
        }
      if (keys.down.isDown) //T key to magically rotate gCoupe toward rCoupe
        {
          if (gCoupe.target===null)
            accelerateAtAngleTo(gCoupe,rCoupe,3/2*pi);
          else accelerateAtAngleTo(gCoupe,gCoupe.target,3/2*pi);
        }
      if (XKey.isDown) //killTangentialVelocity
        {
          killTangentialVelocity(gCoupe,rCoupe);
        }
      if (ZKey.isDown)
        {
          stop(gCoupe);
        }
      if (MKey.isDown)
        {
          if (!!gCoupe.target)
            moveThrough(gCoupe,gCoupe.target);
        }

      if (RKey.isDown) //reset to origin
        {
          gCoupe.x=0;
          gCoupe.y=0;
          gCoupe.vx=0;
          gCoupe.vy=0;
          gCoupe.rv=0;
          gCoupe.rotation=0;
          zoom=1.0;
        }



      graphics.clear();

      for (i=0; i<(mapEdge/100); i++) { //draw grid
        l = new Phaser.Geom.Line﻿(-mapEdge+(i*200),-mapEdge,-mapEdge+(i*200),mapEdge);
        graphics.lineStyle(1, 0x004000);
        graphics.strokeLineShape(l);
      } onkeyup=""
      for (i=-1; i<(mapEdge/100); i++) {
        l = new Phaser.Geom.Line﻿(-mapEdge,-mapEdge+(i*200),mapEdge,-mapEdge+(i*200));
        graphics.lineStyle(1, 0x004000);
        graphics.strokeLineShape(l);
      }

      drawLeft();
      drawRight();

      for (i=0; i<rocks.length; i++){ //rocks phsyics update
        rocks[i].rotation+=dt*rocks[i].rv;
        rocks[i].x+=dt*rocks[i].vx;
        rocks[i].y+=dt*rocks[i].vy;
        if (rocks[i].x<-mapEdge-5) rocks[i].x+=2*mapEdge+10;
        if (rocks[i].x>mapEdge+5) rocks[i].x-=2*mapEdge+10;
        if (rocks[i].y<-mapEdge-5) {
          rocks[i].y+=2*mapEdge+10;
          rocks[i].vx*=-1;
        }
        if (rocks[i].y>mapEdge+10) {
          rocks[i].y-=2*mapEdge+10;
          rocks[i].vx*=-1;
        }
      }

      for (i=0; i<pings.length;i++){ //ping phsyics update
        if (pings[i].t0 + 4 > t) //if ping active over 4 seconds, remove it
        {
          o = pings[i].sender;
          for (k=0;k<o.contacts.length;k++)
          {
            c = o.contacts[k];
            d = Phaser.Math.Distance.Between(c.x,c.y,pings[i].x,pings[i].y)/200;
            ttp = t-pings[i].t0-d;
            if ((ttp>0)&&(ttp<dt)) //if a ping intersects a contact the ping's sender has, check if it still exists
            {
              if (Phaser.Math.Distance.Between(c.x,c.y,c.source.x,c.source.y)>100){
                o.contacts.splice(k,1);
                delete c;
              }

            }

          }
          pings[i].diameter = (t-pings[i].t0)*200;  //*200px/sec
          cc = 4-(t-pings[i].t0); //starts bright, fades with time
          cc*=255/4;
          rgb = Phaser.Display.Color.GetColor(cc,cc,0); //yellow

          graphics.lineStyle(1, rgb, 0.2);
          graphics.beginPath();
          graphics.arc(pings[i].x,pings[i].y,pings[i].diameter,pings[i].pA-pings[i].pW,pings[i].pA+pings[i].pW,false);
          graphics.strokePath();
          graphics.closePath();

          graphics.lineStyle(1, rgb, 0.4);
          graphics.beginPath();
          graphics.arc(pings[i].x,pings[i].y,pings[i].diameter/2,pings[i].pA-pings[i].pW,pings[i].pA+pings[i].pW,false);
          graphics.strokePath();
          graphics.closePath();

          for (j=0; j<rocks.length;j++){
            dms = Phaser.Math.Distance.Between(rocks[j].x,rocks[j].y,pings[i].x,pings[i].y)/200; //distance away in  seconds
            ttp = t-pings[i].t0-dms; //time between ping front and this rock
            if ((ttp>0)&&(ttp<dt)) //if the dms is greater than last frame time but less that this frame time
            {
              a = Math.atan2(rocks[j].y-pings[i].y,rocks[j].x-pings[i].x);
              aa = Math.abs(a-pings[i].pA);
              if (aa<pings[i].pW)
              {
                p = new Phaser.Geom.Circle(rocks[j].x,rocks[j].y);
                p.source = rocks[j];
                p.t0 = t;
                p.pingt0 = pings[i].t0;
                pongs.push(p);  //ping spawns a pong at rocks
              }
            }
          }
          dms = Phaser.Math.Distance.Between(gCoupe.x,gCoupe.y,pings[i].x,pings[i].y)/200; //distance away in seconds
          ttp = t-pings[i].t0-dms; //time between ping front and gCoupe
          if ((ttp>0)&&(ttp<dt)) //if the dms is greater than last frame time but less that this frame time
          {
            a = Math.atan2(gCoupe.y-pings[i].y,gCoupe.x-pings[i].x);
            aa = Math.abs(a-pings[i].pA);
            if (aa<pings[i].pW)
            {
              p = new Phaser.Geom.Circle(gCoupe.x,gCoupe.y);
              p.source = gCoupe;
              p.t0 = t;
              p.pingt0 = pings[i].t0;
              pongs.push(p);  //ping spawns a pong at rocks
            }
          }
          dms = Phaser.Math.Distance.Between(rCoupe.x,rCoupe.y,pings[i].x,pings[i].y)/200; //distance away in seconds
          ttp = t-pings[i].t0-dms; //time between ping front and rCoupe
          if ((ttp>=0)&&(ttp<dt)) //if ping front was crossed within the last frame **bug - ship movement can jump over entire ping frames
          {
            a = Math.atan2(rCoupe.y-pings[i].y,rCoupe.x-pings[i].x);
            aa = Math.abs(a-pings[i].pA);
            if (aa<pings[i].pW)
            {
              p = new Phaser.Geom.Circle(rCoupe.x,rCoupe.y);
              p.source = rCoupe;
              p.t0 = t;
              p.pingt0 = pings[i].t0;
              pongs.push(p);  //ping spawns a pong at rocks
            }
          }

        } else pings.splice(i,1);
      } //end ping physics

      for (i=0; i<pongs.length;i++){ //pong phsyics
        if (pongs[i].pingt0 + 4 > t) //if origin ping active over 4 seconds, remove it
        {
          pongs[i].diameter = (t-pongs[i].t0)*200;  //*200px/sec
          cc = 4-(t-pongs[i].pingt0); //starts bright, fades with time
          cc*=255/4;
          rgb = Phaser.Display.Color.GetColor(cc,cc,cc);
          graphics.lineStyle(1, rgb, 0.2);
          graphics.strokeCircle(pongs[i].x,pongs[i].y,pongs[i].diameter);

          dms = Phaser.Math.Distance.Between(gCoupe.x,gCoupe.y,pongs[i].x,pongs[i].y)/200; //distance away in sec between pongs and gCoupe
          ttp = t-pongs[i].t0-dms; //time between pong front and gCoupe
          if ((ttp>0)&&(ttp<dt)) //if the origin of the pong is between t and dt ago
          {
            b = new Phaser.Geom.Circle(pongs[i].x,pongs[i].y,2);
            if (pongs[i].source===gCoupe) b.rgb=0x80FF80;
            else if (pongs[i].source===rCoupe) b.rgb=0xFF8080;
            else b.rgb=0x8080FF;
            b.source = pongs[i].source;
            b.t0 = pongs[i].t0;
            b.e = pongs[i].e;
            b.last = null;
            ll = null;
            d=mapEdge*4;
            for (j=0;j<gCoupe.blips.length-1;j++) //find nearest blip of the same object
            {
              if (b.source===gCoupe.blips[j].source) {
                dd = Phaser.Math.Distance.Between(gCoupe.blips[j].x,gCoupe.blips[j].y, b.x, b.y);
                if (dd<d) {
                  d=dd;
                  b.last = gCoupe.blips[j]; //point this blip to the nearest blip from the same object
                }
              }
            }
            gCoupe.blips.push(b); //gCoupe adds blip from this pong

            if (!!b.last){
              ll = new Phaser.Geom.Line(b.x,b.y,b.last.x,b.last.y);
              ll.t0=t;
              ll.rgb = b.rgb;
              ll.source = b.source;
              gCoupe.bliplines.push(ll); //if a last blip for this blip's source was found, add a blipline

              cf=false;
              jcf = -1;
              for (j=0; j<gCoupe.contacts.length;j++)
                if (gCoupe.contacts[j].source == ll.source) {
                  cf = true; //find if contact already exists
                  jcf = j;
                }
              if (!cf) // if not, make a new contact
              {
                cc = new Phaser.Geom.Circle(b.x, b.y, 2);
                cc.source = ll.source;
                cc.name = "UO"+ nameInc;
                nameInc+=1;
                while (cc.name.length<6) cc.name = cc.name.slice(0,2) + "0" + cc.name.slice(2); //insert leading zeroes
                cc.vx = (b.x-b.last.x)/(b.t0-b.last.t0); //dvx/dt
                cc.vy = (b.y-b.last.y)/(b.t0-b.last.t0); //dvy/dt
                cc.x = b.x; //project to present
                cc.y = b.y; //project to present
                cc.rgb=Phaser.Display.Color.GetColor(0,255,255);
                cc.t0 = b.t0;
                gCoupe.contacts.push(cc); //keep a list of contacts

                k=gCoupe.contacts.length-1;
                while (k>0){
                  d1 = gCoupe.contacts[k].x+gCoupe.contacts[k].y; //diamond Distance
                  d2 = gCoupe.contacts[k-1].x+gCoupe.contacts[k-1].y; //diamond Distance
                  if (d1<d2){ //bubble the contact down
                    gCoupe.contacts[k] = gCoupe.contacts[k-1];
                    gCoupe.contacts[k-1] = cc;
                  }
                  k--;
                }
              } else {  // if contact exists, update it
                gCoupe.contacts[jcf].x = b.x;
                gCoupe.contacts[jcf].y = b.y;
                gCoupe.contacts[jcf].vx = (b.x-b.last.x)/(b.t0-b.last.t0); //dvx/dt
                gCoupe.contacts[jcf].vy = (b.y-b.last.y)/(b.t0-b.last.t0); //dvy/dt
                gCoupe.contacts[jcf].t0 = b.t0;
              }

            }
          }
        } else pongs.splice(i,1);
      }

      for (i=0; i<missiles.length;i++) {//missile phsyics}
        missiles[i].x+=dt*missiles[i].vx;
        missiles[i].y+=dt*missiles[i].vy;
        if (t<missiles[i].timer){
          if (Phaser.Math.Distance.Between(missiles[i].x, missiles[i].y,missiles[i].target.x,missiles[i].target.y) < 20){
            if (missiles[i].target===rCoupe)
              console.log('You win! LUL!');
            else if (missiles[i].target===gCoupe)
              console.log('You lose! LUL!');
            else
              if (missiles[i].ti > -1)
                rocks[missiles[i].ti].x=-mapEdge;
            boom = this.add.sprite(missiles[i].x, missiles[i].y, 'asplode');
            boom.anims.play('explode',false); //animate the explosion here
            missiles[i].visible = false;
            missiles.splice(i,1);
          } else {
            rrr = Math.atan2(missiles[i].y-missiles[i].target.y, missiles[i].x-missiles[i].target.x);
            missiles[i].rotation = rrr-pi/2; //point at target and accelerate
            accelerateObject(missiles[i]);
            if ((missiles[i].vx*missiles[i].vx + missiles[i].vy*missiles[i].vy)>40000){  //slow down, dang
              missiles[i].vx *= 0.9;
              missiles[i].vy *= 0.9;
            }
          }
        } else {
          boom = this.add.sprite(missiles[i].x, missiles[i].y, 'asplode');
          boom.anims.play('explode',false); //animate the explosion here
          missiles[i].visible = false;
          missiles.splice(i,1);
        }
      }

      gCoupe.rotation+=gCoupe.rv; //ship physics!
      if ((gCoupe.vx*gCoupe.vx + gCoupe.vy*gCoupe.vy)>40000){  //slow down, dang
        gCoupe.vx *= 0.98;
        gCoupe.vy *= 0.98;
      }
      gCoupe.x+=dt*gCoupe.vx;
      gCoupe.y+=dt*gCoupe.vy;

      mx = game.input.mousePointer.x-480+cam.midPoint.x; //don't forget the camera scroll
      my = game.input.mousePointer.y-270+cam.midPoint.y;
      ma = Math.atan2(my-gCoupe.y,mx-gCoupe.x);
      gCoupe.pA = ma;
      pingCircle2.x = 2*mapEdge+105+15*Math.cos(ma);
      pingCircle2.y = 435+15*Math.sin(ma);

      graphics.lineStyle(1, 0xA0A000);
      graphics.beginPath();
      graphics.arc(gCoupe.x,gCoupe.y,10,gCoupe.pA-gCoupe.pW,gCoupe.pA+gCoupe.pW,false);
      graphics.strokePath();
      graphics.closePath();

      doMyBlips(gCoupe);
      doMyBlipLines(gCoupe);


      dd = 4*mapEdge;
      ddi = -1;
      for (i=0; i<gCoupe.contacts.length;i++)
      {
        cc = gCoupe.contacts[i];
        xx = cc.x+cc.vx*(t-cc.t0);
        yy = cc.y+cc.vy*(t-cc.t0);  //first order projection

        if (cc===gCoupe.target)
        {
          gCoupe.target.xx=xx;
          gCoupe.target.yy=yy;

        }
        graphics.lineStyle(2/zoom, cc.rgb, 0.5);
        graphics.strokeCircle(xx,yy,cc.diameter);
        mx = game.input.mousePointer.x-570/zoom;
        my = game.input.mousePointer.y-270/zoom;
        d = Phaser.Math.Distance.Between(mx,my,xx,yy);
        if (d<dd){
          dd=d
          ddi = i;
        }
      }


      d = Phaser.Math.Distance.Between(gCoupe.x,gCoupe.y,rCoupe.x,rCoupe.y);
      if (d<100) { //if close
        accelerateAtAngleTo(rCoupe,gCoupe,pi/2); //rCoupe.rotation=Math.atan2(gCoupe.y-rCoupe.y,gCoupe.x-rCoupe.x); //giver 90
        if (rCoupe.mReady) fireMissile(rCoupe,rCoupe.target);
      } else accelerateAtAngleTo(rCoupe,gCoupe,pi);

      if (Math.abs(rCoupe.vx)>100) rCoupe.vx *= 0.98; //slow if moving too fast
      if (Math.abs(rCoupe.vy)>100) rCoupe.vy *= 0.98  ;
      rCoupe.x+=dt*rCoupe.vx;
      rCoupe.y+=dt*rCoupe.vy;

    } //update end
}); //class end

    function dotProduct(x1,y1,x2,y2)
    {
      return x1*x2+y1*y2;
    }

    function quadratic(a,b,c){
      if (a==0) return -(c/b);
      else
      {
        bb=b/a;
        cc=c/a;
        disc = (bb*bb)-4*cc;
        if (disc<0) return null;
        else {
          disc = Math.sqrt(disc);
          return [(-b-disc)/2,(-b+disc)/2]; //I should only care about the positive root
        }
      }
      return null; // should never be here
    }

    function pulseHitsObject(px, py, pt0, o) { //at what time does pulse p hit object o (assuming linear movement)
      if (o===null) return null;
      else {
        ppx=px-o.x;
        ppy=py-o.y; //change frame of reference by object velocity

        a = Math.pow(o.vx,2) + Math.pow(o.vy,2) - 1;
        b = (o.vx*ppx + o.vy*ppy)*-2; //derived with -v of object in new frame of reference
        c = Math.pow(ppx,2) + Math.pow(ppx,2)
        q = quadratic(a,b,c);
        if (q.length>0)
          return Math.max(q[0],q[1]);
        else return null;
      }
      return null;
    }

    function  accelerateObject(o, acc=o.amax) {
      if (acc>o.amax) acc=o.amax;
      if (acc<0) a=0;
      vAngle = 0;
      if (o.vx!=0) vAngle = Math.atan2(o.vy,o.vx);   //angle of current velocity
      else vAngle = 0;
                                        //angle of acceleration is o.rotation
      ax = acc*dt*Math.sin(o.rotation); //standard acceleration vector
      ay = acc*dt*Math.cos(o.rotation);

      ratio = Phaser.Math.Distance.Between(0,0,o.vx,o.vy)/200; //speed normalized to speed of light
      ax-=ratio*ax*Math.cos(vAngle-o.rotation); //remove/add portion of acceleration relative to speed of light
      ay-=ratio*ay*Math.cos(vAngle-o.rotation);

      o.vx+=ax;
      o.vy-=ay;
    }

    function  rotateObject(o, ra=0){
      if (ra>o.ramax) ra=o.ramax;
      if (ra<-o.ramax) ra=-o.ramax;
      o.rv+=ra*dt;
      if (o.rv > o.rmax) o.rv = o.rmax;
      if (o.rv < -o.rmax) o.rv = -o.rmax;

    }

    function  killRotationObject(o, ra=o.ramax) {
      if (o.rv<0)
        o.rv+=ra*dt;
      else o.rv-=ra*dt;
      if (Math.abs(o.rv)<ra)
        o.rv=0;
    }

    function fireMissile(o, target=null, ri=-1) {
      if ((o.mReady)&&(o.mCount>0))
      {
        m=fM();
        m.x=o.x;
        m.y=o.y;
        m.vx=o.vx;
        m.vy=o.vy;
        m.rotation=o.rotation

        if (target === null)
        {
          ri = targetNearest(o,m);
          if (ri>-1)
            m.target = rocks[ri];
          else
            if (o===gCoupe)
              m.target = rCoupe;
            else m.target = gCoupe;
        } else {
          m.target = target;
        }
        m.ti=ri;
        m.timer = t+5;
        m.amax=2*gameSpeed;
        missiles.push(m);
        o.mReady = false;
        o.mTimer = t+1;
        o.mCount-=1;
      }

    }

    function targetNearest(o,m) {
      mindist = 4*mapEdge;
      ti = -1;
      for (j=0;j<rocks.length;j++){
        d = Phaser.Math.Distance.Between(o.x, o.y, rocks[j].x,rocks[j].y);
        if (d<mindist)
        {
          m.target = rocks[j];
          mindist = d;
          ti=j;
        }
      }
      d=Phaser.Math.Distance.Between(o.x, o.y, gCoupe.x, gCoupe.y);
      if ((d>2)&&(mindist>d))
      {
        m.target = rCoupe;
        mindist = d
        ti=-1;
      }
      d=Phaser.Math.Distance.Between(o.x,o.y,rCoupe.x,rCoupe.y);
      if ((d>2)&&(mindist>d))
      {
        m.target = rCoupe;
        ti=-1;
        mindist = d;
      }
       return ti;

    }

    function  EZrotateTo(o,o2){
      o.rotation = Math.atan2(o.y-o2.y,o.x-o2.x)+3*pi/2;
    } //kind of super cheating

    function  accelerateAtAngleTo(o,o2,a=0)  //for acclelerating toward, away from, or at angle to an object
      {
        a0 = Math.atan2(o.y-o2.y,o.x-o2.x)+3*pi/2; //current angle
        o.rotation = (a0+a)%(2*pi)-pi;
        accelerateObject(o);
      }



    function nextTarget (o)   //find the target with next highest distance, or closest distance if end of list
      {
        if (o.contacts.length>0)
        {
          if (!!o.target)
          {
            i=0;
            while ((o.contacts[i]!==o.target)&&(i<o.contacts.length)) i++;
            if (i>o.contacts.length-1) o.target = o.contacts[0]; //if target is last or not in the list, use the first
            else o.target = o.contacts[i+1]; //use the next
          } else {
            o.target = o.contacts[0];
          }
        }
        else
        {
          o.target = null;
        }
      }

    function cornerBox(x1,y1,x2,y2)
    {
      graphics.lineStyle(1, 0xB0B0B0);
      graphics.strokeLineShape(new Phaser.Geom.Line﻿(x1,y1,x1+2,y1));
      graphics.strokeLineShape(new Phaser.Geom.Line﻿(x2,y1,x2-2,y1));
      graphics.strokeLineShape(new Phaser.Geom.Line﻿(x1,y2,x1+2,y2));
      graphics.strokeLineShape(new Phaser.Geom.Line﻿(x2,y2,x2-2,y2));
      graphics.strokeLineShape(new Phaser.Geom.Line﻿(x1,y1,x1,y1+2));
      graphics.strokeLineShape(new Phaser.Geom.Line﻿(x1,y2,x1,y2-2));
      graphics.strokeLineShape(new Phaser.Geom.Line﻿(x2,y1,x2,y1+2));
      graphics.strokeLineShape(new Phaser.Geom.Line﻿(x2,y2,x2,y2-2));
    }

    function stop(o)
    {
      a = Math.atan2(o.vy,o.vx)-pi/2;
      if (o.vx+o.vy>0.01){
        o.rotation = a;
        accelerateObject(o);
      } else {
        o.vx=0;
        o.vy=0;
      }
      o.rv=0;
    }

    function killTangentialVelocity(o,t)
    {
      a = (Math.atan2(o.vy+o.y-t.y,o.vx+o.x-t.x)+pi)%(2*pi);
        //find the angle between the velocity vector and the relative position vector
      if (a>pi) accelerateAtAngleTo(o,t,pi/2);
        else accelerateAtAngleTo(o,t,-pi/2);
    }

    function moveThrough(o,t)  //oh so broken
    {
        pvx = t.x-o.x;
        pvy = t.y-o.y;
        d = Phaser.Math.Distance.Between(0,0,pvx,pvy);
        v = Phaser.Math.Distance.Between(0,0,o.vx,o.vy);
        dot = dotProduct(o.vx,o.vy,pvx,pvy);
        a = (Math.atan2(o.vy-pvy,o.vx-pvx)+pi)%2*pi;
        if (Math.abs(dot/d/d)<0.01) accelerateAtAngleTo(o,t,pi)
        else
          killTangentialVelocity(o,t);

    }

    function ping(o)
    {
      if (o.pReady)
      {
        p = new Phaser.Geom.Circle(o.x,o.y);
        p.t0 = t;
        p.pA = o.pA;
        p.pW = o.pW;
        p.sender = o;
        pings.push(p);
        o.pReady = false;
        o.pTimer = t + 0.5;
      }
    }

    function doMyBlips(o)
    {
      for (i=0; i<o.blips.length;i++)
      {
          if (t < o.blips[i].t0+10){
            o.blips[i].e -= 0.01;
            cc = 14-(t-o.blips[i].t0); //starts bright, fades with time
            cc*=255/10;
            if (cc>255) cc = 255;
            if (cc<0) cc = 0;
            cc2 = cc-128;
            if (cc2<0) cc2=0;
            if (o.blips[i].source===gCoupe) rgb=Phaser.Display.Color.GetColor(cc2,cc,cc2);   //if blip is gCoupe, make it lgreen
            else if (o.blips[i].source===rCoupe) rgb=Phaser.Display.Color.GetColor(cc,cc2,cc2);         //if blip is rCoupe, make it lred
            else rgb=Phaser.Display.Color.GetColor(cc2,cc2,cc);                                       //else, make it lblue

            graphics.fillStyle(rgb, 0.25);
            graphics.fillCircleShape(o.blips[i]);
          }
          else
          {
            n = 0;
            o.blips.splice(i,1);
          }
      }

    }

    function doMyBlipLines(o)
    {
      bav=0; //Blip Average Velocity
      baa=0; //Blip Average Accel
      for (i=0; i<o.bliplines.length;i++)
      {
          if (t < o.bliplines[i].t0+10){
          cc = 14-(t-o.bliplines[i].t0); //starts bright, fades with time
          cc*=255/10;
          if (cc>255) cc = 255;
          if (cc<0) cc = 0;
          cc2 = cc-128;
          if (cc2<0) cc2=0;
          if (o.bliplines[i].source===gCoupe) rgb=Phaser.Display.Color.GetColor(cc2,cc,cc2);   //if blip is gCoupe, make it lgreen
          else if (o.bliplines[i].source===rCoupe) rgb=Phaser.Display.Color.GetColor(cc,cc2,cc2);         //if blip is rCoupe, make it lred
          else rgb=Phaser.Display.Color.GetColor(cc2,cc2,cc);                                       //else, make it lblue
          graphics.lineStyle(1/zoom, rgb, 1);
          graphics.strokeLineShape(o.bliplines[i]);
        }
        else
        {
          o.bliplines.splice(i,1);
        }
      }
      if (!!o.target) {
        cornerBox(o.target.xx-5,o.target.yy-5,o.target.xx+5,o.target.yy+5);
      }
    }

    function drawLeft()
    {
      graphics.fillStyle(0x0000E0, 0.1);
      graphics.fillRectShape(menuPanel);
      graphics.fillStyle(0xFFC080, 0.1);
      graphics.fillRectShape(pingPanel);
      graphics.fillStyle(0x000000, 0.5);
      graphics.fillRectShape(pingAMinus);
      graphics.fillStyle(0x000000, 0.5);
      graphics.fillRectShape(pingAPlus);
      graphics.fillStyle(0xFFFFA0, 0.2);
      graphics.fillRectShape(pingButton);
      graphics.fillStyle(0xFFA0A0, 0.1);
      graphics.fillCircleShape(accelCircle1);
      graphics.fillStyle(0xD00000, 0.2);
      graphics.fillCircleShape(accelCircle2);
    }

    function drawRight()
    {
      graphics.fillStyle(0x0000E0, 0.1);
      graphics.fillRectShape(resPanel);
      graphics.fillStyle(0xDD80FF, 0.1);
      graphics.fillRectShape(targetPanel);
      graphics.fillStyle(0x000000, 0.5);
      graphics.fillRectShape(zoomMinusButton);
      graphics.fillStyle(0x000000, 0.5);
      graphics.fillRectShape(zoomPlusButton);
      graphics.fillStyle(0x000000, 0.5);
      graphics.fillRectShape(targetButton);
      graphics.fillStyle(0xFF80FF, 0.5);
      graphics.fillRectShape(fireButton);
      graphics.fillStyle(0xFFFF80, 0.1);
      graphics.fillCircleShape(pingCircle1);
      graphics.fillStyle(0xCCCC00, 0.1);
      graphics.fillCircleShape(pingCircle2);
    }

    let config = {
        type: Phaser.AUTO,
        width: 1440,
        height: 900,
        parent:'index.html',
        scene: [MenuScene,GameScene]

    };
let game = new Phaser.Game(config)

</script>

</body>
</html>
